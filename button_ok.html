<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Advanced Cryptocurrency Demo - Atomic Ownership Blockchains Lab</title>
    <script type="importmap">
    {
      "imports": {
        "@google/genai": "https://esm.run/@google/genai"
      }
    }
    </script>
    <!-- Core libraries for P2P networking, UI styling, icons, and graph visualization -->
    <script src="https://unpkg.com/mqtt/dist/mqtt.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://unpkg.com/lucide@latest"></script>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=JetBrains+Mono&family=Plus+Jakarta+Sans:wght@400;600;800&display=swap');
        
        body { font-family: 'Plus Jakarta Sans', sans-serif; background-color: #fcfcfd; color: #1e293b; overflow: hidden; height: 100vh; }
        .mono { font-family: 'JetBrains Mono', monospace; }
        .custom-scrollbar::-webkit-scrollbar { width: 4px; height: 4px; }
        .custom-scrollbar::-webkit-scrollbar-track { background: transparent; }
        .custom-scrollbar::-webkit-scrollbar-thumb { background: #e2e8f0; border-radius: 10px; }
        
        .tab-content { display: none; height: calc(100vh - 280px); }
        .tab-content.active { display: flex; flex-direction: column; }
        
        /* 
         * FIX: Using display: none by default. 
         * Previously, display: flex with opacity: 0 could still trap mouse events in some webkit versions despite pointer-events: none.
         */
        .fixed-overlay { 
            position: fixed; top: 0; left: 0; right: 0; bottom: 0; 
            background-color: rgba(15, 23, 42, 0.6); backdrop-filter: blur(4px); 
            display: none; /* Changed from flex to none to prevent clicking interference */
            opacity: 0; pointer-events: none; transition: opacity 0.3s ease; z-index: 100; 
        }
        .fixed-overlay.open { display: flex; opacity: 1; pointer-events: auto; }
        
        #details-overlay, #ai-overlay { justify-content: flex-end; }
        #details-content, #ai-content { width: 100%; max-width: 550px; height: 100%; background: white; box-shadow: -10px 0 30px rgba(0,0,0,0.1); transform: translateX(100%); transition: transform 0.4s cubic-bezier(0.16, 1, 0.3, 1); display: flex; flex-direction: column; }
        #details-overlay.open #details-content, #ai-overlay.open #ai-content { transform: translateX(0); }

        .btn-box { display: flex; align-items: center; gap: 0.5rem; padding: 0.75rem 1.5rem; border-radius: 0.75rem; font-size: 0.875rem; font-weight: 800; text-transform: uppercase; letter-spacing: 0.05em; transition: all 0.2s; border: 2px solid transparent; }
        .btn-active { background-color: #4f46e5; color: white; box-shadow: 0 10px 15_3px rgba(0, 0, 0, 0.1); cursor: pointer; }
        .btn-inactive { background-color: #f1f5f9; color: #94a3b8; cursor: not-allowed; opacity: 0.5; }
        
        .tab-btn { padding-top: 1rem; padding-bottom: 1rem; font-size: 0.875rem; font-weight: 700; border-bottom: 4px solid transparent; color: #94a3b8; transition: all 0.2s; }
        .tab-btn.active { border-bottom-color: #4f46e5; color: #4f46e5; }

        .card { background-color: white; border: 2px solid #e2e8f0; border-radius: 1rem; padding: 1rem; transition: all 0.2s; width: 12rem; flex-shrink: 0; cursor: pointer; position: relative; }
        .card:hover { border-color: #4f46e5; box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1); }

        /* Block status colors */
        .chain-local { border-color: #3b82f6 !important; background-color: #eff6ff !important; }
        .chain-remote { border-color: #f59e0b !important; background-color: #fffbeb !important; }
        .chain-mortgaged { border-color: #94a3b8 !important; border-style: dashed !important; opacity: 0.6; filter: grayscale(1); }

        #network-svg { width: 100%; height: 100%; background: #fff; }
        .node { stroke: #fff; stroke-width: 3px; cursor: pointer; transition: fill 0.3s; }
        .node-blacklisted { fill: #ef4444 !important; stroke: #991b1b !important; }
        .link { stroke: #cbd5e1; stroke-opacity: 0.6; stroke-width: 1.5px; }
        
        .chan-local { border-color: #4f46e5 !important; background-color: #f5f3ff !important; }
        .chan-hybrid { border-color: #10b981 !important; background-color: #f0fdf4 !important; }
        .chan-remote { border-color: #f59e0b !important; background-color: #fffbeb !important; }
        
        .participant-local { background-color: #4f46e5; color: white; padding: 0.1rem 0.3rem; border-radius: 0.25rem; }

        /* AI Message Styles */
        .ai-message { border-radius: 1rem; padding: 1rem; margin-bottom: 1rem; max-width: 90%; line-height: 1.6; }
        .ai-msg-user { align-self: flex-end; background-color: #4f46e5; color: white; font-weight: 600; }
        .ai-msg-bot { align-self: flex-start; background-color: #f1f5f9; color: #1e293b; border: 1px solid #e2e8f0; font-weight: 500; }
        .help-q-mark { color: #94a3b8; cursor: pointer; transition: color 0.2s; display: inline-flex; align-items: center; justify-content: center; }
        .help-q-mark:hover { color: #4f46e5; transform: scale(1.1); }
    </style>
</head>
<body class="min-h-screen flex flex-col">

    <header class="bg-white border-b border-slate-200 p-8 z-30 flex-shrink-0">
        <div class="max-w-7xl mx-auto flex justify-between items-start">
            <div class="space-y-2">
                <p class="text-xs font-black text-indigo-600 uppercase tracking-[0.3em]">Atomic Ownership TestNet</p>
                <h1 id="main-title" class="text-3xl font-black text-slate-900 tracking-tighter flex items-center gap-2">
                    先进加密货币示范网
                    <button onclick="window.askAI('intro')" class="help-q-mark"><i data-lucide="help-circle" size="20"></i></button>
                </h1>
                <div id="status-line" class="text-sm text-slate-500 font-bold leading-relaxed flex flex-wrap items-center gap-3">
                    <span id="instruction-text"></span>
                    <div id="readiness-badges" class="flex flex-wrap gap-2"></div>
                </div>
            </div>
            <div class="flex flex-col items-end gap-3">
                <div id="mqtt-status" class="px-4 py-2 bg-amber-50 text-amber-600 text-[10px] font-black rounded-full uppercase border border-amber-100">Broker: Connecting...</div>
                <div class="flex gap-2">
                    <button onclick="window.toggleLanguage()" class="px-4 py-2 bg-slate-100 hover:bg-slate-200 text-slate-600 text-[10px] font-black rounded-full uppercase transition-colors">
                        <span id="lang-toggle-text">English</span>
                    </button>
                    <button onclick="window.askAI('help')" class="w-8 h-8 flex items-center justify-center bg-indigo-600 text-white rounded-full hover:bg-indigo-700 transition-colors shadow-lg">
                        <i data-lucide="sparkles" size="16"></i>
                    </button>
                </div>
            </div>
        </div>
        
        <div class="max-w-7xl mx-auto mt-8 flex flex-wrap gap-4 items-center" id="action-buttons">
            <!-- Buttons dynamically generated by updateStepUI -->
        </div>
    </header>

    <nav class="bg-white border-b border-slate-100 px-8 flex-shrink-0">
        <div class="max-w-7xl mx-auto flex gap-10">
            <button onclick="window.switchTab('help')" id="tab-btn-help" class="tab-btn active flex items-center gap-2"><span data-t="tab_help">使用指南</span> <i data-lucide="help-circle" size="16"></i></button>
            <button onclick="window.switchTab('nodes')" id="tab-btn-nodes" class="tab-btn flex items-center gap-2"><span data-t="tab_nodes">网络节点</span> <i data-lucide=\"server\" size=\"16\"></i></button>
            <button onclick="window.switchTab('accounts')" id="tab-btn-accounts" class="tab-btn flex items-center gap-2"><span data-t="tab_accounts">账户</span> <i data-lucide=\"user-square\" size=\"16\"></i></button>
            <button onclick="window.switchTab('chains')" id="tab-btn-chains" class="tab-btn flex items-center gap-2"><span data-t="tab_chains">区块链钞票</span> <i data-lucide=\"box\" size=\"16\"></i></button>
            <button onclick="window.switchTab('channels')" id="tab-btn-channels" class="tab-btn flex items-center gap-2"><span data-t="tab_channels">快速通道</span> <i data-lucide=\"zap\" size=\"16\"></i></button>
        </div>
    </nav>

    <main class="flex-grow bg-slate-50/50 relative overflow-hidden">
        <div id="tab-help" class="tab-content active p-10 overflow-y-auto custom-scrollbar">
            <!-- Content populated by script -->
        </div>
        <div id="tab-nodes" class="tab-content overflow-hidden">
            <div class="flex-1 bg-white relative"><svg id="network-svg"></svg></div>
        </div>
        <div id="tab-accounts" class="tab-content p-10 overflow-y-auto custom-scrollbar">
            <div class="max-w-7xl mx-auto">
                <div id="account-grid-local" class="flex flex-wrap gap-6 mb-12"></div>
                <div id="account-grid-remote" class="flex flex-wrap gap-6"></div>
            </div>
        </div>
        <div id="tab-chains" class="tab-content p-10 overflow-y-auto custom-scrollbar">
            <div class="max-w-7xl mx-auto"><div id="chain-grid" class="flex flex-wrap gap-6"></div></div>
        </div>
        <div id="tab-channels" class="tab-content p-10 overflow-y-auto custom-scrollbar">
            <div class="max-w-7xl mx-auto"><div id="channel-grid" class="flex flex-wrap gap-6"></div></div>
        </div>
    </main>

    <div id="details-overlay" class="fixed-overlay" onclick="if(event.target==this) window.closeOverlay()">
        <div id="details-content" onclick="event.stopPropagation()">
            <div class="p-10 border-b border-slate-100 flex justify-between items-center bg-white/50 backdrop-blur">
                <h2 id="overlay-title" class="text-2xl font-black text-slate-900 uppercase">详情</h2>
                <button onclick="window.closeOverlay()" class="p-3 hover:bg-slate-100 rounded-full"><i data-lucide="x"></i></button>
            </div>
            <div id="overlay-body" class="flex-1 overflow-y-auto custom-scrollbar p-10 space-y-8 pb-20"></div>
        </div>
    </div>

    <!-- AI Chat Overlay -->
    <div id="ai-overlay" class="fixed-overlay" onclick="if(event.target==this) window.closeAI()">
        <div id="ai-content" onclick="event.stopPropagation()">
            <div class="p-10 border-b border-slate-100 flex justify-between items-center bg-indigo-50/50">
                <div class="flex items-center gap-3">
                    <div class="w-10 h-10 bg-indigo-600 rounded-full flex items-center justify-center text-white shadow-lg">
                        <i data-lucide="sparkles" size="20"></i>
                    </div>
                    <div>
                        <h2 id="ai-header-title" class="text-xl font-black text-slate-900 uppercase tracking-tighter">AOB AI Assistant</h2>
                        <p id="ai-header-status" class="text-[10px] font-bold text-indigo-600 uppercase tracking-widest">Always Online</p>
                    </div>
                </div>
                <button onclick="window.closeAI()" class="p-3 hover:bg-slate-100 rounded-full"><i data-lucide="x"></i></button>
            </div>
            <div id="ai-messages" class="flex-1 overflow-y-auto custom-scrollbar p-10 flex flex-col space-y-4">
                <!-- AI messages here -->
            </div>
            <div class="p-6 border-t border-slate-100 bg-white">
                <div class="flex gap-2 bg-slate-50 p-2 rounded-2xl border border-slate-200 ring-1 ring-white shadow-inner">
                    <input id="ai-input" type="text" placeholder="..." class="flex-1 bg-transparent px-4 py-3 text-sm font-bold outline-none" onkeypress="if(event.key==='Enter') window.sendAIMessage()">
                    <button onclick="window.sendAIMessage()" class="bg-indigo-600 text-white p-3 rounded-xl hover:bg-indigo-700 transition-colors shadow-md active:scale-95">
                        <i data-lucide="send" size="18"></i>
                    </button>
                </div>
            </div>
        </div>
    </div>

    <script type="module">
        import { GoogleGenAI } from "@google/genai";

        // Global Diagnostic Logger
        const logger = {
            log: (...args) => console.log("%c[AOB-LAB]", "color: #4f46e5; font-weight: bold;", ...args),
            error: (...args) => console.error("%c[AOB-LAB-ERROR]", "color: #ef4444; font-weight: bold;", ...args),
            warn: (...args) => console.warn("%c[AOB-LAB-WARN]", "color: #f59e0b; font-weight: bold;", ...args)
        };

        logger.log("Module initialization started.");

        const AI_HELP_PROMPTS = {
            zh: {
                'intro': '请向我介绍一下 AOB 技术和这个模拟器的功能。',
                'help': '我该如何操作？下一步该点哪里？',
                'init_net': '如何建立网络？AOB协议的网络层是如何工作的？',
                'init_accounts': '如何创建用户账户？AOB中的账户和节点是什么关系？',
                'init_assets': '什么是区块链钞票？AOB是如何实现原子所有权的？',
                'init_channels': '什么是快速通道（Speedy Channel）？它是如何解决扩容问题的？',
                'node_detail': '节点详情页有哪些功能？节点是如何处理广播和消息转发的？',
                'account_detail': '账户详情页能做什么？如何创建到其他账户的快速通道？',
                'chain_detail': '区块链钞票的详细信息怎么看？如何进行支付？',
                'channel_detail': '快速通道详情页的功能说明。什么是级联支付？',
                'node_logs': '节点的广播历史有什么用？我该如何阅读同步日志？',
                'node_broadcast': '如何通过节点发送广播测试？这在 AOB 协议中扮演什么角色？',
                'acc_chains': '账户的资产列表显示了什么？资产状态有哪些？',
                'chain_history': '区块链的溯源历史是如何验证所有权的？',
                'chan_pool': '快速通道的钞票存池是如何运作的？为什么要抵押资产？',
                'chan_cascade': '级联支付的原理是什么？为什么它是原子性的？'
            },
            en: {
                'intro': 'Please introduce AOB technology and the features of this simulator.',
                'help': 'What should I do? Where should I click next?',
                'init_net': 'How to establish the network? How does the network layer of AOB protocol work?',
                'init_accounts': 'How to create user accounts? What is the relationship between accounts and nodes in AOB?',
                'init_assets': 'What are blockchain banknotes? How does AOB achieve atomic ownership?',
                'init_channels': 'What are Speedy Channels? How do they solve the scalability problem?',
                'node_detail': 'Functions of node details. How do nodes handle broadcasting and forwarding?',
                'account_detail': 'What to do on account details? How to create a Speedy Channel?',
                'chain_detail': 'How to view banknote details and perform a transfer?',
                'channel_detail': 'Speedy Channel details explanation. What is cascade payment?',
                'node_logs': 'Purpose of node broadcast history and sync logs.',
                'node_broadcast': 'How to send broadcast tests? What role does it play in AOB?',
                'acc_chains': 'What does the account asset list show? States explanation.',
                'chain_history': 'How does the provenance history verify ownership?',
                'chan_pool': 'How does the channel banknote pool work? Why mortgage?',
                'chan_cascade': 'Principle of cascade payment and why it is atomic.'
            }
        };

        const mdToHtml = (md) => {
            if (!md) return '';
            return md
                .replace(/### (.*)/g, '<h3 class="text-base font-black text-indigo-600 mt-4 mb-2">$1</h3>')
                .replace(/## (.*)/g, '<h2 class="text-lg font-black text-slate-900 mt-6 mb-3">$2</h2>')
                .replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>')
                .replace(/\n/g, '<br>');
        };

        let aiInstance = null;
        let aiChat = null;
        let appDocContext = "";

        const fetchContext = async () => {
            try {
                const reqRes = await fetch('request.md');
                const reqText = await reqRes.text();
                const helpRes = await fetch('help.md');
                const helpText = await helpRes.text();
                appDocContext = `CONTEXT INFORMATION FROM request.md:\n${reqText}\n\nCONTEXT FROM help.md:\n${helpText}`;
                logger.log("Context documents loaded.");
            } catch (e) {
                logger.warn("Context fetch failed. Proceeding with defaults.");
                appDocContext = "Atomic Ownership Blockchains (AOB) Lab. Decentralized currency simulation.";
            }
        };

        window.closeAI = () => {
            document.getElementById('ai-overlay').classList.remove('open');
            setTimeout(() => { document.getElementById('ai-overlay').style.display = 'none'; }, 300);
        };

        window.askAI = async (topicId) => {
            const overlay = document.getElementById('ai-overlay');
            const messagesEl = document.getElementById('ai-messages');
            overlay.style.display = 'flex';
            setTimeout(() => overlay.classList.add('open'), 10);
            
            document.getElementById('ai-header-title').innerText = currentLang === 'zh' ? 'AOB AI 助手' : 'AOB AI Assistant';
            document.getElementById('ai-header-status').innerText = currentLang === 'zh' ? '正在运行' : 'Live Engine';
            document.getElementById('ai-input').placeholder = currentLang === 'zh' ? '询问关于 AOB 的任何问题...' : 'Ask anything about AOB...';

            if (topicId === 'general' && messagesEl.innerHTML.trim() !== '') return;

            const initialMsg = AI_HELP_PROMPTS[currentLang][topicId] || AI_HELP_PROMPTS[currentLang]['help'];
            
            if (!aiInstance) {
                aiInstance = new GoogleGenAI({ apiKey: process.env.API_KEY });
                await fetchContext();
            }

            aiChat = aiInstance.chats.create({
                model: 'gemini-3-flash-preview',
                config: {
                    systemInstruction: `You are a technical expert for the "Advanced Cryptocurrency Demonstration" platform (AOB Lab). 
                    UI LANGUAGE: ${currentLang === 'zh' ? 'Chinese' : 'English'}
                    RULES: Match input language. Under 200 words. Guide user on step ${simulationState.step}.`,
                }
            });

            appendAIMessage('user', initialMsg);
            const botMsgEl = appendAIMessage('bot', currentLang === 'zh' ? '思考中...' : 'Thinking...');
            
            try {
                const langForce = currentLang === 'zh' ? " (请用中文回答)" : " (Response in English)";
                const response = await aiChat.sendMessageStream({ message: initialMsg + langForce });
                let fullText = "";
                botMsgEl.innerHTML = "";
                for await (const chunk of response) {
                    fullText += chunk.text;
                    botMsgEl.innerHTML = mdToHtml(fullText);
                    messagesEl.scrollTop = messagesEl.scrollHeight;
                }
            } catch (e) {
                botMsgEl.innerText = "Error: " + e.message;
            }
        };

        window.sendAIMessage = async (customText) => {
            const input = document.getElementById('ai-input');
            const msg = (customText || input.value).trim();
            if (!msg) return;
            if (!customText) input.value = '';
            if (!aiChat) await window.askAI('help');
            
            appendAIMessage('user', msg);
            const botMsgEl = appendAIMessage('bot', currentLang === 'zh' ? '思考中...' : 'Thinking...');
            try {
                const containsChinese = /[\u4e00-\u9fa5]/.test(msg);
                const forcedLang = containsChinese ? " (请用中文回答)" : " (Response in English)";
                const response = await aiChat.sendMessageStream({ message: msg + forcedLang });
                let fullText = "";
                botMsgEl.innerHTML = "";
                for await (const chunk of response) {
                    fullText += chunk.text;
                    botMsgEl.innerHTML = mdToHtml(fullText);
                    document.getElementById('ai-messages').scrollTop = document.getElementById('ai-messages').scrollHeight;
                }
            } catch (e) { botMsgEl.innerText = "Error: " + e.message; }
        };

        function appendAIMessage(role, text) {
            const container = document.getElementById('ai-messages');
            const div = document.createElement('div');
            div.className = `ai-message ${role === 'user' ? 'ai-msg-user' : 'ai-msg-bot'} text-sm shadow-sm`;
            div.innerHTML = role === 'user' ? text : mdToHtml(text);
            container.appendChild(div);
            container.scrollTop = container.scrollHeight;
            return div;
        }

        const helpIcon = (topic) => `<button onclick="event.stopPropagation(); window.askAI('${topic}')" class="help-q-mark ml-1"><i data-lucide="help-circle" size="14"></i></button>`;

        const TRANSLATIONS = {
            zh: {
                title: "先进加密货币示范网",
                lang_toggle: "English",
                instruction_0: "点击第一个按钮创建 P2P 网络节点。",
                instruction_4: "快速通道就绪，可通过通道进行快速支付。",
                ready_prefix: "网络就绪级别: ",
                ready_suffix: "。请继续下一步。",
                btn_init_net: "建立网络",
                btn_init_accounts: "创建账户",
                btn_init_assets: "创建区块链钞票",
                btn_init_channels: "创建快速通道",
                tab_help: "使用指南",
                tab_nodes: "网络节点",
                tab_accounts: "账户",
                tab_chains: "区块链钞票",
                tab_channels: "快速通道",
                overlay_details: "详情",
                overlay_node: "节点控制台",
                overlay_account_local: "本地账户控制台",
                overlay_account_remote: "远端同步账户",
                overlay_chain: "钞票详情",
                overlay_channel: "快速通道详情",
                node_peers: "邻节点",
                node_accounts: "托管账户",
                node_broadcast: "发送广播测试",
                node_broadcast_placeholder: "输入报文...",
                node_broadcast_btn: "广播",
                node_logs: "同步历史",
                node_blacklist: "黑名单 (违规作者)",
                no_logs: "暂无消息。",
                no_accounts: "无",
                acc_balance: "资产流动性",
                acc_create_channel: "创建快速通道",
                acc_create_channel_btn: "建立通道",
                acc_chains: "所属资产",
                chain_status: "状态",
                chain_pay: "签署支付",
                chain_pay_btn: "签署并广播",
                chain_history: "溯源记录",
                chan_pay: "原子支付",
                chan_direct: "直接支付",
                chan_cascade: "级联模式",
                chan_cascade_builder: "原子级联路径构建",
                chan_cascade_exec: "签署并广播更新",
                chan_hop: "跳",
                chan_via: "经由通道",
                status_mortgaged: "已抵押",
                status_free: "可用",
                log_sync: "[同步]",
                log_test: "[测试]",
                log_security: "[安全警告]",
                log_author: "作者",
                log_content: "内容",
                log_msg_id: "ID",
                ready_net: "网络",
                ready_users: "账户",
                ready_assets: "钞票",
                ready_channels: "通道",
                broker_online: "Broker: 已连接",
                broker_connecting: "Broker: 连接中...",
                cascade_insufficient: "路径余额不足或连接断开。",
                cascade_broken: "路径构建失败：参与者不连续。",
                help_content: `<div class="max-w-4xl mx-auto bg-white p-12 rounded-[3rem] shadow-xl space-y-10">
                        <h2 class="text-3xl font-black text-slate-900 tracking-tighter">欢迎来到先进加密货币示范平台。</h2>
                        <div class="space-y-8 text-slate-600 leading-relaxed font-bold text-base">
                            <p>这是一个真实运行的加密货币系统，在此使用者能构建基于原子物权链实现的创新架构。</p>
                            <p>AOB 用微观的公域私有链构建货币系统，将每条区块链视为一张道具钞票。</p>
                        </div>
                    </div>`
            },
            en: {
                title: "Advanced Cryptocurrency TestNet",
                lang_toggle: "中文",
                instruction_0: "Click the first button to initialize the P2P network nodes.",
                instruction_4: "Speedy channels ready. Instant payments available.",
                ready_prefix: "Ready level: ",
                ready_suffix: ". Proceed to next step.",
                btn_init_net: "Establish Network",
                btn_init_accounts: "Create Accounts",
                btn_init_assets: "Create Banknotes",
                btn_init_channels: "Create Speedy Channels",
                tab_help: "Guide",
                tab_nodes: "Nodes",
                tab_accounts: "Accounts",
                tab_chains: "Banknotes",
                tab_channels: "Channels",
                overlay_details: "Details",
                overlay_node: "Node Console",
                overlay_account_local: "Local Account",
                overlay_account_remote: "Remote Account",
                overlay_chain: "Banknote Details",
                overlay_channel: "Speedy Channel Details",
                node_peers: "Peers",
                node_accounts: "Hosted Accounts",
                node_broadcast: "Broadcast Test",
                node_broadcast_placeholder: "Enter message...",
                node_broadcast_btn: "Broadcast",
                node_logs: "Sync Logs",
                node_blacklist: "Blacklist (Bad Authors)",
                no_logs: "No messages.",
                no_accounts: "None",
                acc_balance: "Liquidity",
                acc_create_channel: "Create Channel",
                acc_create_channel_btn: "Establish Channel",
                acc_chains: "Owned Assets",
                chain_status: "Status",
                chain_pay: "Sign Transfer",
                chain_pay_btn: "Sign & Broadcast",
                chain_history: "Provenance",
                chan_pay: "Atomic Pay",
                chan_direct: "Direct Pay",
                chan_cascade: "Cascade Mode",
                chan_cascade_builder: "Cascade Path Builder",
                chan_cascade_exec: "Sign & Execute",
                chan_hop: "Hop",
                chan_via: "via",
                status_mortgaged: "Locked",
                status_free: "Free",
                log_sync: "[Sync]",
                log_test: "[Test]",
                log_security: "[Security Warning]",
                log_author: "Author",
                log_content: "Content",
                log_msg_id: "ID",
                ready_net: "Network",
                ready_users: "Accounts",
                ready_assets: "Assets",
                ready_channels: "Channels",
                broker_online: "Broker: Online",
                broker_connecting: "Broker: Connecting...",
                cascade_insufficient: "Insufficient path balance or disconnection.",
                cascade_broken: "Path failed: Discontinuous participants.",
                help_content: `<div class="p-10">AOB Guide goes here...</div>`
            }
        };

        const r2 = (n) => Math.round((n + Number.EPSILON) * 100) / 100;
        const r0 = (n) => Math.round(n);

        const urlParams = new URLSearchParams(window.location.search);
        var currentLang = urlParams.get('lang') || localStorage.getItem('aob_lang') || 'zh';
        if (currentLang !== 'zh' && currentLang !== 'en') currentLang = 'zh';

        function t(key) { return TRANSLATIONS[currentLang][key] || key; }

        var activeOverlayId = null;

        window.toggleLanguage = function() {
            currentLang = currentLang === 'zh' ? 'en' : 'zh';
            localStorage.setItem('aob_lang', currentLang);
            updateLanguageContent();
            updateStepUI();
            renderAll();
            if (activeOverlayId) {
                const id = activeOverlayId;
                if (id.startsWith('NODE-')) window.openNodeOverlay(id);
                else if (id.startsWith('CHAN-')) window.openChannelOverlay(id);
                else if (simulationState.users.some(u => u.pub === id) || simulationState.remoteUsers.includes(id)) window.openAccountOverlay(id);
                else window.openChainOverlay(id);
            }
            aiChat = null;
        };

        function updateLanguageContent() {
            const helpTab = document.getElementById('tab-help');
            if (helpTab) helpTab.innerHTML = t('help_content');
            document.documentElement.lang = currentLang === 'zh' ? 'zh-CN' : 'en';
            if (document.getElementById('main-title')) document.getElementById('main-title').innerText = t('title');
            if (document.getElementById('lang-toggle-text')) document.getElementById('lang-toggle-text').innerText = t('lang_toggle');
            const s = document.getElementById('mqtt-status');
            const connectedCount = mqttClients.filter(c => c.connected).length;
            if (s) {
                if (connectedCount > 0) {
                    s.innerText = `${t('broker_online')} (${connectedCount}/${mqttClients.length})`;
                    s.className = "px-4 py-2 bg-green-50 text-green-600 text-[10px] font-black rounded-full uppercase border border-green-100";
                } else {
                    s.innerText = t('broker_connecting');
                    s.className = "px-4 py-2 bg-amber-50 text-amber-600 text-[10px] font-black rounded-full uppercase border border-amber-100";
                }
            }
            document.querySelectorAll('[data-t]').forEach(el => el.innerText = t(el.getAttribute('data-t')));
            if (window.lucide) lucide.createIcons();
        }

        var mqttClients = []; 
        var superUser = null;
        var appInstanceId = localStorage.getItem('aob_instance_id') || Math.random().toString(36).substr(2, 4).toUpperCase();
        localStorage.setItem('aob_instance_id', appInstanceId);

        var cascadeSession = { active: false, path: [], initiatorIdx: 0 }; 
        var currentOpenedChannelId = null;

        var simulationState = { 
            nodes: [], users: [], remoteUsers: [], 
            chains: [], speedyChannels: [], step: 0,
            processedIds: new Set(),
            pendingMortgages: [],
            activeAmount: 10.00,
            readyFlags: [], 
            instanceId: appInstanceId
        };

        const CONFIG = {
            NODE_COUNT: 30, ACCOUNT_COUNT: 10, BANKNOTE_COUNT: 100,
            BROKERS: ['wss://test.mosquitto.org:8081', 'ws://test.mosquitto.org:8080'],
            TOPIC_MESH: 'aob/v25/global_mesh', TOPIC_DISCOVERY: 'aob/v25/discovery', TOPIC_P2P: 'aob/v25/p2p',
            DEFINITION_TEXT: "Define each blockchain as a banknote, with the data structure of its genesis block as: H\\\\nS\\\\nK, where: H is the SHA256 hash of this document (Base64); K is the public key of the super user (Base64), fixed at [SysPubKey]; S is the serial number, with the following correspondence to the banknote's denomination:\\n1-20 1\\n21-40 5\\n41-60 10\\n61-80 20\\n81-100 50"
        };

        async function verifyBlockSignature(data, sig, pubB64) {
            try {
                const pubKeyBytes = new Uint8Array(atob(pubB64).split("").map(c => c.charCodeAt(0)));
                const publicKey = await crypto.subtle.importKey("raw", pubKeyBytes, { name: "ECDSA", namedCurve: "P-256" }, true, ["verify"]);
                const sigBytes = new Uint8Array(atob(sig).split("").map(c => c.charCodeAt(0)));
                return await crypto.subtle.verify({ name: "ECDSA", hash: { name: "SHA-256" } }, publicKey, sigBytes, new TextEncoder().encode(data));
            } catch (e) { return false; }
        }

        function multiPublish(topic, message) {
            mqttClients.forEach(client => { if (client.connected) client.publish(topic, message); });
        }

        function multiSubscribe(topic) {
            mqttClients.forEach(client => { client.subscribe(topic); });
        }

        async function saveFullState() {
            try {
                const existingRaw = localStorage.getItem('aob_lab_v25_secure_final');
                const existing = existingRaw ? JSON.parse(existingRaw) : {};

                const data = {
                    ...existing,
                    step: simulationState.step,
                    readyFlags: simulationState.readyFlags,
                    instanceId: simulationState.instanceId,
                    remoteUsers: simulationState.remoteUsers.length > 0 ? simulationState.remoteUsers : existing.remoteUsers
                };

                if (simulationState.nodes.length > 0) {
                    data.nodes = simulationState.nodes.map(n => ({ 
                        ...n, ledger: undefined, seenIds: undefined, logs: n.logs.slice(0, 50),
                        blacklist: Array.from(n.blacklist || [])
                    }));
                }
                
                if (simulationState.users.length > 0) {
                    data.users = await Promise.all(simulationState.users.map(async u => {
                        const jwk = await crypto.subtle.exportKey("jwk", u.keyPair.privateKey);
                        return { ...u, jwk, keyPair: undefined };
                    }));
                    data.superUserPub = simulationState.superUserPub || existing.superUserPub;
                    if (superUser) {
                        data.superUserJwk = await crypto.subtle.exportKey("jwk", superUser.keyPair.privateKey);
                    }
                }
                
                if (simulationState.chains.length > 0) data.chains = simulationState.chains;
                if (simulationState.speedyChannels.length > 0) data.speedyChannels = simulationState.speedyChannels;

                localStorage.setItem('aob_lab_v25_secure_final', JSON.stringify(data));
            } catch (e) { logger.error("Persistence error", e); }
        }

        async function getHash(text) { const hb = await crypto.subtle.digest('SHA-256', new TextEncoder().encode(text)); return btoa(String.fromCharCode(...new Uint8Array(hb))); }
        async function generateKeyPair() { const kp = await crypto.subtle.generateKey({ name: "ECDSA", namedCurve: "P-256" }, true, ["sign", "verify"]); const rp = await crypto.subtle.exportKey("raw", kp.publicKey); const p = btoa(String.fromCharCode(...new Uint8Array(rp))); return { pub: p, fp: p.slice(0, 8), keyPair: kp }; }
        async function signData(d, pk) { const s = await crypto.subtle.sign({ name: "ECDSA", hash: { name: "SHA-256" } }, pk, new TextEncoder().encode(d)); return btoa(String.fromCharCode(...new Uint8Array(s))); }

        function startDiscovery() {
            if (simulationState.step >= 1) {
                const locals = simulationState.nodes.filter(n => n.instance === appInstanceId);
                if (locals.length > 0) {
                    const n = locals[Math.floor(Math.random() * locals.length)];
                    multiPublish(CONFIG.TOPIC_DISCOVERY, JSON.stringify({ type: 'HELLO', id: n.id, instance: appInstanceId, neighbors: n.neighbors }));
                }
            }
        }

        window.initNetwork = async function() {
            logger.log("initNetwork triggered.");
            try {
                const savedRaw = localStorage.getItem('aob_lab_v25_secure_final');
                const saved = savedRaw ? JSON.parse(savedRaw) : null;
                
                if (saved && saved.nodes && saved.nodes.length > 0) {
                    logger.log(`Restoring saved nodes from previous session.`);
                    simulationState.nodes = (saved.nodes || []).map(n => ({ ...n, ledger: {}, seenIds: new Set(), logs: n.logs || [], blacklist: new Set(n.blacklist) }));
                    simulationState.instanceId = saved.instanceId || appInstanceId;
                    simulationState.remoteUsers = saved.remoteUsers || [];
                } else {
                    logger.log(`No saved nodes. Generating new network.`);
                    const locals = Array.from({ length: CONFIG.NODE_COUNT }, (_, i) => ({
                        id: `NODE-${appInstanceId}-${i}`, instance: appInstanceId, neighbors: [], logs: [], seenIds: new Set(), ledger: {}, blacklist: new Set()
                    }));
                    locals.forEach(n => {
                        while (n.neighbors.length < 4) {
                            const t_node = locals[Math.floor(Math.random() * locals.length)];
                            if (t_node.id !== n.id && !n.neighbors.includes(t_node.id) && t_node.neighbors.length < 7) {
                                n.neighbors.push(t_node.id); t_node.neighbors.push(n.id);
                            }
                            if (locals.every(an => an.neighbors.length >= 7 || an.id === n.id)) break;
                        }
                    });
                    simulationState.nodes = locals;
                }
                
                simulationState.step = 1;
                simulationState.readyFlags = [t('ready_net')];
                
                simulationState.nodes.filter(n => n.instance === appInstanceId).forEach(n => multiSubscribe(`${CONFIG.TOPIC_P2P}/${n.id}`));
                
                updateStepUI(); 
                initNetworkViz();
                startDiscovery(); 
                setInterval(startDiscovery, 15000);
                await saveFullState();
                window.switchTab('nodes');
            } catch (e) {
                logger.error("Network Init Error:", e);
            }
        };

        window.initAccounts = async function() {
            logger.log("initAccounts triggered.");
            const savedRaw = localStorage.getItem('aob_lab_v25_secure_final');
            const saved = savedRaw ? JSON.parse(savedRaw) : null;
            
            if (saved && saved.users && saved.users.length > 0) {
                 logger.log("Restoring saved accounts from previous session.");
                 simulationState.superUserPub = saved.superUserPub;
                 if (saved.superUserJwk) {
                     const spriv = await crypto.subtle.importKey("jwk", saved.superUserJwk, { name: "ECDSA", namedCurve: "P-256" }, true, ["sign"]);
                     superUser = { pub: saved.superUserPub, keyPair: { privateKey: spriv } };
                 }
                 simulationState.users = await Promise.all((saved.users || []).map(async u => {
                     const priv = await crypto.subtle.importKey("jwk", u.jwk, { name: "ECDSA", namedCurve: "P-256" }, true, ["sign"]);
                     return { ...u, keyPair: { privateKey: priv } };
                 }));
            } else {
                logger.log(`No saved accounts. Creating new ones.`);
                const nodesPool = simulationState.nodes;
                if (nodesPool.length === 0) { logger.error("No nodes found for account binding."); return; }

                superUser = await generateKeyPair(); simulationState.superUserPub = superUser.pub;
                for (let i = 0; i < CONFIG.ACCOUNT_COUNT; i++) {
                    const kp = await generateKeyPair(); 
                    kp.nodes = [
                        nodesPool[i % nodesPool.length].id, 
                        nodesPool[(i + 5) % nodesPool.length].id, 
                        nodesPool[(i + 10) % nodesPool.length].id
                    ];
                    simulationState.users.push(kp);
                }
            }
            
            simulationState.step = 2;
            simulationState.readyFlags = [t('ready_net'), t('ready_users')];
            updateStepUI(); 
            window.switchTab('accounts');
            await saveFullState();
        };

        window.initBanknotes = async function() {
            const defFull = CONFIG.DEFINITION_TEXT.replace("[SysPubKey]", superUser.pub);
            const h = await getHash(defFull);
            for (let s = 1; s <= CONFIG.BANKNOTE_COUNT; s++) {
                const gData = `${h}\\\\n${s}\\\\n${superUser.pub}`; 
                const gId = await getHash(gData);
                const genesis = { id: gId, type: 'GENESIS', author: superUser.pub, chainRootId: gId, data: gData };
                const target = simulationState.users[Math.floor(Math.random() * simulationState.users.length)];
                const ts = Date.now();
                const payData = `PREV:${gId}\\\\nTYPE:PAYMENT\\\\nTARGET:${target.pub}\\\\nTS:${ts}`;
                const sig = await signData(payData, superUser.keyPair.privateKey);
                const payment = { id: sig, type: 'PAYMENT', author: superUser.pub, target: target.pub, chainRootId: gId, data: payData, sig };
                await updateGlobalState(genesis); await updateGlobalState(payment);
                multiPublish(CONFIG.TOPIC_MESH, JSON.stringify({ block: genesis }));
                multiPublish(CONFIG.TOPIC_MESH, JSON.stringify({ block: payment }));
            }
            simulationState.readyFlags = [t('ready_net'), t('ready_users'), t('ready_assets')];
            simulationState.step = 3; updateStepUI(); window.switchTab('chains'); 
            await saveFullState();
        };

        function areUsersAdjacent(u1Pub, u2Pub) {
            const u1 = simulationState.users.find(u => u.pub === u1Pub);
            const u2 = simulationState.users.find(u => u.pub === u2Pub);
            if (!u1 || !u2) return true;
            const n1s = u1.nodes || [], n2s = u2.nodes || [];
            for (let n1 of n1s) {
                if (n2s.includes(n1)) return true;
                const nodeObj = simulationState.nodes.find(x => x.id === n1);
                if (nodeObj && nodeObj.neighbors.some(nb => n2s.includes(nb))) return true;
            }
            return false;
        }

        window.initChannels = async function() {
            const users = simulationState.users;
            const remotes = simulationState.remoteUsers;
            for (let round = 0; round < 20; round++) {
                for (let i = 0; i < users.length; i++) {
                    let curCount = simulationState.speedyChannels.filter(c => c.participants.some(p => p.pub === users[i].pub)).length;
                    if (curCount >= 4) continue;
                    let targets = [...users.filter(u => u.pub !== users[i].pub).map(u => u.pub), ...remotes];
                    targets.sort(() => Math.random() - 0.5);
                    for (let targetPub of targets) {
                        if (areUsersAdjacent(users[i].pub, targetPub)) {
                            const sorted = [users[i].pub, targetPub].sort();
                            if (!simulationState.speedyChannels.find(c => c.participants[0].pub === sorted[0] && c.participants[1].pub === sorted[1])) {
                                const u2Obj = users.find(u => u.pub === targetPub) || { pub: targetPub, nodes: ['REMOTE-NODE'] };
                                await createAndBroadcastChannel(users[i], u2Obj);
                                if (++curCount >= 4) break;
                            }
                        }
                    }
                }
            }
            simulationState.readyFlags = [t('ready_net'), t('ready_users'), t('ready_assets'), t('ready_channels')];
            simulationState.step = 4; updateStepUI(); window.switchTab('channels'); 
            await saveFullState();
        };

        async function createAndBroadcastChannel(u1, u2) {
            const sorted = [u1.pub, u2.pub].sort();
            const rootData = `Speedy Channel\\\\\\\\n${Date.now()}\\\\\\\\n${sorted[0]}\\\\\\\\n${u1.nodes ? u1.nodes[0] : 'UNK'}\\\\\\\\n${sorted[1]}\\\\\\\\n${u2.nodes ? u2.nodes[0] : 'UNK'}`;
            const cId = await getHash(rootData); 
            if (!simulationState.speedyChannels.find(x => x.id === cId)) {
                const block = { id: cId, type: 'SPEEDY_CHANNEL_ROOT', author: u1.pub, chainRootId: cId, data: rootData };
                await updateGlobalState(block);
                multiPublish(CONFIG.TOPIC_MESH, JSON.stringify({ block: block }));
                [u1, u2].forEach(async participant => {
                    const localMe = simulationState.users.find(u => u.pub === participant.pub);
                    if (localMe) {
                        const myAssets = simulationState.chains.filter(asset => asset.currentOwner === localMe.pub && asset.status === 'FREE').sort((a,b) => b.denomination - a.denomination);
                        if (myAssets[0]) {
                            const mData = `PREV:${myAssets[0].blocks[myAssets[0].blocks.length-1].id}\\\\\\\\nTYPE:MORTGAGE\\\\\\\\nTARGET:${cId}\\\\\\\\nTS:${Date.now()}`;
                            const sig = await signData(mData, localMe.keyPair.privateKey);
                            const mBlock = { id: sig, type: 'MORTGAGE', author: localMe.pub, target: cId, chainRootId: myAssets[0].genesisId, data: mData, sig };
                            await updateGlobalState(mBlock);
                            multiPublish(CONFIG.TOPIC_MESH, JSON.stringify({ block: mBlock }));
                        }
                    }
                });
            }
            return cId;
        }

        async function updateGlobalState(block) {
            if (simulationState.processedIds.has(block.id)) return;
            const locals = simulationState.nodes.filter(n => n.instance === appInstanceId);
            
            for (let n of locals) {
                if (n.blacklist && n.blacklist.has(block.author)) return;
                if (block.sig) {
                    const valid = await verifyBlockSignature(block.data, block.sig, block.author);
                    if (!valid) return;
                }
                let chain = simulationState.chains.find(x => x.genesisId === block.chainRootId);
                if (chain && block.type !== 'GENESIS') {
                    const parts = block.data.split('\\\\\\\\n');
                    const prevIdLine = parts.find(p => p.startsWith('PREV:'));
                    const prevId = prevIdLine ? prevIdLine.replace('PREV:', '') : '';
                    const fork = chain.blocks.find(b => b.data.includes(`PREV:${prevId}`) && b.id !== block.id);
                    if (fork) {
                        if (!n.blacklist) n.blacklist = new Set();
                        n.blacklist.add(block.author);
                        updateNetworkViz();
                        return;
                    }
                }
            }

            simulationState.processedIds.add(block.id);
            locals.forEach(n => {
                n.seenIds.add(block.id);
                n.logs.unshift({ time: new Date().toLocaleTimeString(), type: block.type, data: `Synced ID:${block.id.slice(0,12)}...` });
                if(n.logs.length > 50) n.logs.pop();
            });

            const addUserIfRemote = (pub) => {
                if (pub && pub.length > 60 && !simulationState.users.find(u => u.pub === pub) && !simulationState.remoteUsers.includes(pub)) {
                    simulationState.remoteUsers.push(pub);
                }
            };
            addUserIfRemote(block.author);
            if (block.type === 'PAYMENT') addUserIfRemote(block.target);

            let c = simulationState.chains.find(x => x.genesisId === block.chainRootId);
            if (block.type === 'GENESIS' && !c) {
                const parts = block.data.split('\\\\\\\\n'); const s = +parts[1]; 
                let d = s > 80 ? 50 : s > 60 ? 20 : s > 40 ? 10 : s > 20 ? 5 : 1;
                c = { serial: s, denomination: r0(d), genesisId: block.id, blocks: [block], currentOwner: 'SYSTEM', status: 'FREE' };
                simulationState.chains.push(c);
            } else if (c) {
                if (!c.blocks.find(b => b.id === block.id)) {
                    c.blocks.push(block);
                    if (block.type === 'PAYMENT') { c.currentOwner = block.target; c.status = 'FREE'; }
                    else if (block.type === 'MORTGAGE') {
                        c.status = 'MORTGAGED'; c.currentOwner = block.target;
                        const ch = simulationState.speedyChannels.find(x=>x.id===block.target);
                        if(ch) {
                            const p = ch.participants.find(p=>p.pub===block.author);
                            if(p) p.balance = r2(p.balance + c.denomination);
                        } else { simulationState.pendingMortgages.push({ target: block.target, author: block.author, value: c.denomination, genesisId: c.genesisId }); }
                    }
                }
            }
            if (block.type === 'SPEEDY_CHANNEL_ROOT' && !simulationState.speedyChannels.find(x => x.id === block.id)) {
                const l = block.data.split('\\\\\\\\n');
                const chan = { id: block.id, participants: [{pub:l[2], fp:l[2].slice(0,8), balance:0.00, node:l[3]}, {pub:l[4], fp:l[4].slice(0,8), balance:0.00, node:l[5]}], history: [] };
                simulationState.speedyChannels.push(chan);
                simulationState.pendingMortgages = simulationState.pendingMortgages.filter(pm => {
                    if (pm.target === block.id) {
                        const p = chan.participants.find(p => p.pub === pm.author); if (p) p.balance = r2(p.balance + pm.value);
                        const chain = simulationState.chains.find(x => x.genesisId === pm.genesisId); if (chain) chain.currentOwner = block.id;
                        return false;
                    }
                    return true;
                });
            }
            window.renderAll();
        }

        function handleIncomingRelay(msg) {
            simulationState.nodes.filter(n => n.instance === appInstanceId).forEach(n => {
                if (!n.seenIds.has(msg.mId)) {
                    if (n.neighbors.includes(msg.fromNode) || msg.originator === n.id) {
                        n.seenIds.add(msg.mId);
                        const logEntry = `[${msg.type}] From:${msg.originator}\\\\\\\\n${t('log_content')}: ${msg.content || 'P2P Broadcast'}`;
                        n.logs.unshift({ time: new Date().toLocaleTimeString(), type: msg.type, data: logEntry });
                        if(n.logs.length > 50) n.logs.pop();
                        if (msg.hop < 4) multiPublish(CONFIG.TOPIC_MESH, JSON.stringify({ relay: { ...msg, fromNode: n.id, hop: msg.hop + 1 } }));
                    }
                }
            });
        }

        function relayToNeighbors(node, payload) {
            node.neighbors.forEach(nbId => { multiPublish(CONFIG.TOPIC_MESH, JSON.stringify({ relay: { ...payload, fromNode: node.id, hop: 0 } })); });
        }

        window.switchTab = function(id) {
            document.querySelectorAll('.tab-content').forEach(t_el => t_el.classList.remove('active'));
            const target = document.getElementById(`tab-${id}`);
            if (target) target.classList.add('active');
            document.querySelectorAll('.tab-btn').forEach(b => { 
                b.classList.remove('active'); 
                if(b.id === `tab-btn-${id}`) b.classList.add('active'); 
            });
            if(id === 'nodes' && simulation) updateNetworkViz();
            window.renderAll();
        };

        window.renderAll = function() {
            const lGrid = document.getElementById('account-grid-local'); if(lGrid) {
                lGrid.innerHTML = '';
                simulationState.users.forEach(u => {
                    const bal = r0(simulationState.chains.filter(c => c.currentOwner === u.pub && c.status === 'FREE').reduce((s,c)=>s+c.denomination, 0));
                    const el = document.createElement('div'); el.className = 'card flex flex-col items-center gap-3 shadow-sm';
                    el.onclick = () => window.openAccountOverlay(u.pub);
                    el.innerHTML = `<div class="p-3 bg-indigo-50 rounded-full text-indigo-600"><i data-lucide="user"></i></div><div class="text-sm font-black text-slate-800">$${bal}</div><div class="text-[9px] mono text-slate-400 font-bold">${u.fp}</div>`;
                    lGrid.appendChild(el);
                });
            }
            const rGrid = document.getElementById('account-grid-remote'); if(rGrid) {
                rGrid.innerHTML = '';
                simulationState.remoteUsers.forEach(pub => {
                    const el = document.createElement('div'); el.className = 'card flex flex-col items-center gap-3 opacity-60 grayscale scale-95';
                    el.onclick = () => window.openAccountOverlay(pub);
                    el.innerHTML = `<div class="p-3 bg-slate-100 rounded-full text-slate-400"><i data-lucide="user"></i></div><div class="text-[10px] font-bold text-slate-500 uppercase">Remote</div><div class="text-[9px] mono text-slate-300 font-bold">${pub.slice(0,8)}</div>`;
                    rGrid.appendChild(el);
                });
            }
            const cGrid = document.getElementById('chain-grid'); if(cGrid) {
                cGrid.innerHTML = '';
                simulationState.chains.forEach(c => {
                    const isLocal = simulationState.users.some(u => u.pub === c.currentOwner);
                    const el = document.createElement('div');
                    let stateClass = c.status === 'MORTGAGED' ? "chain-mortgaged" : (isLocal ? "chain-local" : "chain-remote");
                    el.className = `card text-center ${stateClass}`;
                    el.onclick = () => window.openChainOverlay(c.genesisId);
                    el.innerHTML = `<div class="text-xl font-black chain-val">$${r0(c.denomination)}</div><div class="text-[9px] mono text-slate-500 font-bold mt-1 uppercase">ID:${c.genesisId.slice(0,8)}</div>`;
                    cGrid.appendChild(el);
                });
            }
            const chGrid = document.getElementById('channel-grid'); if(chGrid) {
                chGrid.innerHTML = '';
                simulationState.speedyChannels.forEach(c => {
                    const isLocal1 = simulationState.users.some(u => u.pub === c.participants[0].pub);
                    const isLocal2 = simulationState.users.some(u => u.pub === c.participants[1].pub);
                    let typeClass = (isLocal1 && isLocal2) ? "chan-local" : (isLocal1 || isLocal2) ? "chan-hybrid" : "chan-remote";
                    let typeLabel = (isLocal1 && isLocal2) ? "LOCAL" : (isLocal1 || iLocal2) ? "HYBRID" : "REMOTE";
                    const el = document.createElement('div'); el.className = `card ${typeClass}`;
                    el.onclick = () => window.openChannelOverlay(c.id);
                    el.innerHTML = `<div class="text-[9px] font-black mb-2 uppercase tracking-tighter opacity-70">${typeLabel} CHANNEL</div><div class="flex justify-between items-center text-xs"><div class="text-center font-bold"><div>$${c.participants[0].balance.toFixed(2)}</div><div class="text-[8px] opacity-60 ${isLocal1?'participant-local':''}">${c.participants[0].fp}</div></div><i data-lucide="zap" class="opacity-40" size="14"></i><div class="text-center font-bold"><div>$${c.participants[1].balance.toFixed(2)}</div><div class="text-[8px] opacity-60 ${isLocal2?'participant-local':''}">${c.participants[1].fp}</div></div></div>`;
                    chGrid.appendChild(el);
                });
            }
            if(window.lucide) lucide.createIcons();
            const badgeContainer = document.getElementById('readiness-badges');
            if (badgeContainer) badgeContainer.innerHTML = simulationState.readyFlags.map(f => `<span class="px-2 py-0.5 bg-indigo-50 text-indigo-600 rounded text-[10px] uppercase font-black tracking-widest border border-indigo-100">${f}</span>`).join('');
        };

        window.openNodeOverlay = function(id) {
            const n = simulationState.nodes.find(x => x.id === id); if(!n) return;
            activeOverlayId = id;
            const boundUsers = simulationState.users.filter(u => u.nodes && u.nodes.includes(id));
            window.openOverlay(`${t('overlay_node')}: ${id}`);
            document.getElementById('overlay-body').innerHTML = `
                <div class="space-y-6">
                    <div class="p-6 bg-slate-900 rounded-[2rem] text-white shadow-xl border-4 border-indigo-900/30">
                        <div class="text-[10px] uppercase font-black tracking-widest text-indigo-400 mb-3">${t('node_accounts')} (${boundUsers.length})</div>
                        <div class="space-y-2 mb-4">
                            ${boundUsers.map(u => `<button onclick="window.openAccountOverlay('${u.pub}')" class="w-full text-left text-[9px] mono bg-indigo-500/10 px-3 py-2 rounded-lg border border-indigo-500/20 hover:bg-indigo-500/30 flex justify-between items-center"><span>${u.fp}...</span></button>`).join('') || `<div class="text-xs italic text-slate-500">${t('no_accounts')}</div>`}
                        </div>
                        <div class="text-[10px] uppercase font-black tracking-widest text-indigo-400 mb-3">${t('node_peers')} (${n.neighbors.length})</div>
                        <div class="flex flex-wrap gap-2">${n.neighbors.map(nb => `<button onclick="window.openNodeOverlay('${nb}')" class="text-[9px] mono bg-slate-800 px-3 py-1.5 rounded-lg border border-slate-700 hover:border-indigo-500 transition-colors">${nb}</button>`).join('') || `<div class="text-xs italic text-slate-500">${t('no_accounts')}</div>`}</div>
                    </div>
                    ${n.blacklist && n.blacklist.size > 0 ? `<div class="p-4 bg-red-50 border border-red-100 rounded-xl"><h4 class="text-[10px] font-black text-red-600 mb-1 uppercase">${t('node_blacklist')}</h4><div class="text-[8px] mono text-red-400">${Array.from(n.blacklist).map(x=>x.slice(0,16)+'...').join('<br>')}</div></div>` : ''}
                    <div class="p-8 bg-indigo-50 border-2 border-indigo-100 rounded-[2rem] space-y-4 shadow-inner">
                        <h4 class="text-[10px] font-black uppercase text-indigo-600 tracking-widest flex items-center gap-2"><i data-lucide="radio" size="14"></i> ${t('node_broadcast')}</h4>
                        <div class="flex gap-2"><input id="node-test-input" type="text" placeholder="${t('node_broadcast_placeholder')}" class="flex-1 bg-white p-3 rounded-xl text-xs font-bold outline-none ring-1 ring-slate-200"><button onclick="window.broadcastTest('${id}')" class="bg-indigo-600 text-white px-6 py-3 rounded-xl font-black text-[10px] uppercase shadow-md">${t('node_broadcast_btn')}</button></div>
                    </div>
                    <div class="space-y-3">
                        <h4 class="text-[10px] font-black uppercase text-slate-400 tracking-widest">${t('node_logs')}</h4>
                        <div class="space-y-2 max-h-80 overflow-y-auto custom-scrollbar">${n.logs.map(l => `<div class="p-4 border bg-white rounded-2xl flex flex-col gap-1 shadow-sm"><div class="flex justify-between items-center"><span class="text-[8px] font-black bg-slate-100 px-2 py-0.5 rounded text-slate-500 uppercase">${l.type}</span><span class="text-[8px] font-bold text-slate-400 mono">${l.time}</span></div><div class="text-[10px] font-bold text-slate-700 break-all leading-relaxed whitespace-pre-wrap">${l.data}</div></div>`).join('') || `<div class="text-xs text-slate-300 italic text-center py-8">${t('no_logs')}</div>`}</div>
                    </div>
                </div>`;
            if(window.lucide) lucide.createIcons();
        };

        window.broadcastTest = (nid) => {
            const input = document.getElementById('node-test-input'); if(!input.value) return;
            const node = simulationState.nodes.find(x => x.id === nid);
            const mId = Math.random().toString(36).substr(2, 9);
            relayToNeighbors(node, { type: 'BROADCAST_TEST', content: input.value, originator: nid, mId });
            node.logs.unshift({ time: new Date().toLocaleTimeString(), type: 'BROADCAST_TEST', data: `${t('log_test')} Author:${nid}\\\\n${t('log_content')}: ${input.value}` });
            input.value = ''; setTimeout(() => { if (activeOverlayId === nid) window.openNodeOverlay(nid); }, 100);
        };

        window.openAccountOverlay = function(pub) {
            const isLocal = simulationState.users.some(u => u.pub === pub);
            const ownedChains = simulationState.chains.filter(c => c.currentOwner === pub);
            const others = [...simulationState.users.filter(u=>u.pub!==pub).map(u=>u.pub), ...simulationState.remoteUsers.filter(u=>u!==pub)];
            activeOverlayId = pub;
            window.openOverlay(isLocal ? t('overlay_account_local') : t('overlay_account_remote'));
            document.getElementById('overlay-body').innerHTML = `
                <div class="space-y-6">
                    <div class="p-10 ${isLocal?'bg-indigo-600':'bg-slate-600'} text-white rounded-[2.5rem] text-center shadow-xl">
                        <div class="text-[10px] opacity-60 font-black tracking-widest mb-2 uppercase">${t('acc_balance')}</div>
                        <div class="text-6xl font-black">$${ownedChains.filter(c=>c.status==='FREE').reduce((s,c)=>s+c.denomination,0)}</div>
                        <div class="mt-6 text-[9px] mono opacity-60 break-all select-all font-bold">${pub}</div>
                    </div>
                    ${isLocal ? `
                    <div class="p-8 bg-white border-2 border-indigo-50 rounded-[2.5rem] space-y-4 shadow-sm">
                        <h4 class="text-[10px] font-black uppercase text-indigo-600 tracking-widest">${t('acc_create_channel')}</h4>
                        <div class="flex flex-col gap-3">
                            <select id="manual-ch-target" class="w-full bg-slate-50 p-4 rounded-xl text-[10px] mono outline-none ring-1 ring-slate-200">
                                ${others.map(t_pub => `<option value="${t_pub}">${t_pub.slice(0,16)}... (${simulationState.users.some(u => u.pub === t_pub) ? 'Local' : 'Remote'})</option>`).join('')}
                            </select>
                            <button onclick="window.execManualChannel('${pub}')" class="bg-indigo-600 text-white py-4 rounded-xl font-black text-xs uppercase shadow-md active:scale-95">${t('acc_create_channel_btn')}</button>
                        </div>
                    </div>
                    ` : ''}
                    <div class="space-y-3">
                        <h4 class="text-[10px] font-black uppercase text-slate-400 tracking-widest">${t('acc_chains')} (${ownedChains.length})</h4>
                        <div class="grid grid-cols-2 gap-2">
                            ${ownedChains.map(c => `<button onclick="window.openChainOverlay('${c.genesisId}')" class="p-4 border-2 ${c.status==='FREE'?'border-indigo-50 hover:border-indigo-200':'border-slate-100 grayscale opacity-50'} bg-white rounded-2xl text-center"><div class="text-xl font-black text-slate-800">$${c.denomination}</div><div class="text-[8px] mono text-slate-400 font-bold uppercase mt-1">ID:${c.genesisId.slice(0,8)}</div></button>`).join('') || `<div class="text-xs text-slate-300 italic py-4 text-center col-span-2">No Assets</div>`}
                        </div>
                    </div>
                </div>`;
            if(window.lucide) lucide.createIcons();
        };

        window.execManualChannel = async function(localPub) {
            const targetPub = document.getElementById('manual-ch-target').value;
            const u1 = simulationState.users.find(u => u.pub === localPub);
            const u2 = simulationState.users.find(u => u.pub === targetPub) || { pub: targetPub, nodes: ['REMOTE-NODE'] };
            if (!areUsersAdjacent(u1.pub, u2.pub)) {
                alert("Accounts are not on adjacent nodes.");
                return;
            }
            await createAndBroadcastChannel(u1, u2);
            window.closeOverlay(); window.switchTab('channels'); await saveFullState();
        };

        window.openChainOverlay = function(id) {
            const c = simulationState.chains.find(x => x.genesisId === id); if(!c) return;
            activeOverlayId = id;
            const isLocal = simulationState.users.some(u => u.pub === c.currentOwner);
            const others = [...simulationState.users.filter(u=>u.pub!==c.currentOwner).map(u=>u.pub), ...simulationState.remoteUsers.filter(u=>u!==c.currentOwner)];
            window.openOverlay(`${t('overlay_chain')}: ${id.slice(0,12)}`);
            document.getElementById('overlay-body').innerHTML = `
                <div class="space-y-6">
                    <div class="p-10 bg-emerald-50 border-4 border-emerald-100 rounded-[3rem] text-center">
                        <div class="text-7xl font-black text-emerald-600">$${c.denomination}</div>
                        <div class="text-[10px] font-black uppercase text-slate-400 mt-4 tracking-widest">${t('chain_status')}: ${c.status === 'FREE' ? t('status_free') : t('status_mortgaged')}</div>
                    </div>
                    ${isLocal && c.status === 'FREE' ? `
                    <div class="p-8 bg-white border-2 border-indigo-50 rounded-[2.5rem] space-y-5 shadow-lg">
                        <h4 class="text-[10px] font-black uppercase text-slate-400 tracking-widest">${t('chain_pay')}</h4>
                        <select id="pay-target-select" class="w-full bg-slate-50 p-4 rounded-xl text-[10px] mono outline-none ring-1 ring-slate-200">
                            ${others.map(target_pub => `<option value="${target_pub}">${target_pub.slice(0,16)}...</option>`).join('')}
                        </select>
                        <button onclick="window.execPayment('${id}')" class="w-full bg-indigo-600 text-white py-5 rounded-xl font-black uppercase text-xs shadow-xl active:scale-95">${t('chain_pay_btn')}</button>
                    </div>` : `<div class="p-10 text-center text-xs italic bg-slate-50 rounded-2xl">Read Only</div>`}
                    <div class="space-y-3">
                        <h4 class="text-[10px] font-black uppercase text-slate-400 tracking-widest">${t('chain_history')}</h4>
                        <div class="space-y-2">
                            ${c.blocks.map(b => `<div class="p-4 border bg-white rounded-2xl text-[10px] shadow-sm"><div class="flex justify-between font-black text-indigo-600 mb-1"><span>${b.type}</span><span class="mono">${b.id.slice(0,16)}...</span></div><div class="text-slate-500 mono break-all whitespace-pre-wrap">${b.data.replace(/\\\\\\\\n/g, ' | ')}</div></div>`).join('')}
                        </div>
                    </div>
                </div>`;
        };

        window.execPayment = async function(chainId) {
            const c = simulationState.chains.find(x => x.genesisId === chainId), target = document.getElementById('pay-target-select').value, owner = simulationState.users.find(u => u.pub === c.currentOwner);
            const data = `PREV:${c.blocks[c.blocks.length-1].id}\\\\nTYPE:PAYMENT\\\\nTARGET:${target}\\\\nTS:${Date.now()}`;
            const sig = await signData(data, owner.keyPair.privateKey);
            const block = { id: sig, type: 'PAYMENT', author: c.currentOwner, target, chainRootId: chainId, data: data, sig };
            await updateGlobalState(block); multiPublish(CONFIG.TOPIC_MESH, JSON.stringify({ block }));
            window.closeOverlay(); await saveFullState();
        };

        window.openChannelOverlay = function(id) { activeOverlayId = id; currentOpenedChannelId = id; cascadeSession = { active: false, path: [id], initiatorIdx: 0 }; window.refreshChannelUI(id); };
        window.refreshChannelUI = function(id) {
            const chan = simulationState.speedyChannels.find(x => x.id === id); if (!chan) return;
            const p1 = chan.participants[0], p2 = chan.participants[1], isP1Local = simulationState.users.some(u => u.pub === p1.pub), isP2Local = simulationState.users.some(u => u.pub === p2.pub);
            window.openOverlay(t('overlay_channel'));
            document.getElementById('overlay-body').innerHTML = `
                <div class="space-y-6 pb-20">
                    <div class="p-12 bg-slate-900 rounded-[3.5rem] flex justify-between items-center text-white shadow-2xl border-4 border-indigo-900/30">
                        <div class="text-center flex-1">
                            <div class="text-5xl font-black">$${p1.balance.toFixed(2)}</div>
                            <div class="text-[9px] mono text-indigo-400 mt-2 font-bold ${isP1Local?'participant-local':''}">${p1.fp}</div>
                        </div>
                        <i data-lucide="zap" class="text-emerald-500 animate-pulse" size="40"></i>
                        <div class="text-center flex-1">
                            <div class="text-5xl font-black">$${p2.balance.toFixed(2)}</div>
                            <div class="text-[9px] mono text-indigo-400 mt-2 font-bold ${isP2Local?'participant-local':''}">${p2.fp}</div>
                        </div>
                    </div>
                    <div class="p-8 bg-white border-2 border-indigo-50 rounded-[2.5rem] space-y-6 shadow-lg">
                        <h4 class="text-[10px] font-black uppercase text-slate-400 tracking-widest">${t('chan_pay')}</h4>
                        <div class="flex gap-4">
                            <select id="ch-sender" class="flex-1 bg-slate-50 p-3 rounded-lg text-xs font-black outline-none">
                                <option value="0" ${!isP1Local ? 'disabled' : ''}>${p1.fp}</option>
                                <option value="1" ${!isP2Local ? 'disabled' : ''}>${p2.fp}</option>
                            </select>
                            <input id="ch-amt" type="number" step="any" oninput="simulationState.activeAmount = Number(this.value)" class="w-24 bg-slate-50 p-4 rounded-xl text-xs font-black outline-none" value="${simulationState.activeAmount}">
                        </div>
                        <div class="grid grid-cols-2 gap-4">
                            <button onclick="window.execChPay('${id}')" class="bg-indigo-600 text-white py-4 rounded-xl font-black text-[10px] uppercase shadow-lg">${t('chan_direct')}</button>
                            <button onclick="window.startCascadeMode('${id}')" class="bg-indigo-50 text-indigo-600 py-4 rounded-xl font-black text-[10px] uppercase">${t('chan_cascade')}</button>
                        </div>
                    </div>
                    <div id=\\\"cascade-builder\\\" class=\\\"${cascadeSession.active ? '' : 'hidden'} p-8 bg-indigo-50 rounded-[2.5rem] shadow-inner border-2 border-indigo-100 space-y-4\\\">
                        <h4 class=\\\"text-[11px] font-black uppercase text-indigo-600 tracking-widest\\\">${t('chan_cascade_builder')}</h4>
                        <div id=\\\"cascade-steps\\\" class=\\\"space-y-2\\\"></div>
                        <div id=\\\"cascade-next\\\" class=\\\"pt-4 border-t border-indigo-100\\\"></div>
                        <button onclick=\\\"window.executeCascade()\\\" class=\\\"w-full bg-indigo-600 text-white py-5 rounded-2xl font-black uppercase text-xs shadow-xl mt-4\\\">${t('chan_cascade_exec')}</button>
                    </div>
                </div>`;
            if(window.lucide) lucide.createIcons();
            if(cascadeSession.active) window.updateCascadeList();
        };

        window.startCascadeMode = (id) => { cascadeSession.active = true; cascadeSession.initiatorIdx = +document.getElementById('ch-sender').value; cascadeSession.path = [id]; window.refreshChannelUI(id); };

        window.updateCascadeList = () => {
            const stepsEl = document.getElementById('cascade-steps'), nextEl = document.getElementById('cascade-next'); if(!stepsEl) return;
            const initialChan = simulationState.speedyChannels.find(x => x.id === cascadeSession.path[0]);
            let curPub = initialChan.participants[cascadeSession.initiatorIdx].pub;
            stepsEl.innerHTML = cascadeSession.path.map((cid, i) => {
                const chan = simulationState.speedyChannels.find(x => x.id === cid), sender = chan.participants.find(p => p.pub === curPub), receiver = chan.participants.find(p => p.pub !== curPub);
                if (!sender) return `<div class="p-4 bg-red-50 text-red-600 rounded-xl text-xs font-black">${t('cascade_broken')}</div>`;
                curPub = receiver.pub;
                return `<div class="p-4 bg-white rounded-2xl text-[10px] border-2 border-indigo-100 flex flex-col gap-1 shadow-sm"><div class="flex justify-between font-black text-indigo-600 uppercase"><span>${t('chan_hop')} #${i+1}</span><span class="mono">ID:${cid.slice(0,8)}</span></div><div class="flex items-center gap-2 mt-1"><span class="mono px-2 py-0.5 bg-indigo-50 rounded font-bold">${sender.fp}</span><i data-lucide=\\\"arrow-right\\\" size=\\\"10\\\" class=\\\"text-slate-300\\\"></i><span class=\\\"mono px-2 py-0.5 bg-emerald-50 rounded font-bold\\\">${receiver.fp}</span></div></div>`;
            }).join('');
            const others = simulationState.speedyChannels.filter(c => !cascadeSession.path.includes(c.id) && c.participants.some(p => p.pub === curPub));
            nextEl.innerHTML = others.map(o => `<button onclick=\\\"window.addCascadeHop('${o.id}')\\\" class=\\\"w-full bg-white p-4 rounded-2xl text-[10px] text-indigo-700 text-left border-2 border-dashed border-indigo-200 hover:border-indigo-400 transition-all flex justify-between items-center\\\"><div><span class=\\\"font-black\\\">${t('chan_via')} ${o.id.slice(0,8)}</span></div><i data-lucide=\\\"plus\\\" size=\\\"14\\\"></i></button>`).join('') || `<div class=\\\"text-xs italic text-slate-400 py-4\\\">No hops found</div>`;
            if(window.lucide) lucide.createIcons();
        };

        window.addCascadeHop = (id) => { cascadeSession.path.push(id); window.updateCascadeList(); };
        window.executeCascade = async () => {
            const amt = r2(Number(simulationState.activeAmount)); if (isNaN(amt) || amt <= 0) return;
            const initialChan = simulationState.speedyChannels.find(x => x.id === cascadeSession.path[0]);
            let curPub = initialChan.participants[cascadeSession.initiatorIdx].pub;
            for (let cid of cascadeSession.path) {
                const c = simulationState.speedyChannels.find(x => x.id === cid);
                const s = c.participants.find(p => p.pub === curPub);
                if (!s || s.balance < amt) { alert(t('cascade_insufficient')); return; }
                curPub = c.participants.find(p => p.pub !== curPub).pub;
            }
            curPub = initialChan.participants[cascadeSession.initiatorIdx].pub;
            cascadeSession.path.forEach(cid => {
                const c = simulationState.speedyChannels.find(x => x.id === cid);
                const sIdx = c.participants.findIndex(p => p.pub === curPub);
                const receiver = c.participants[sIdx === 0 ? 1 : 0];
                const msgId = Math.random().toString(36).substr(2, 9);
                multiPublish(`${CONFIG.TOPIC_P2P}/${receiver.node}`, JSON.stringify({ type: 'SPEEDY_CHANNEL_UPDATE', msgId: msgId, channelId: cid, senderPub: curPub, amount: amt }));
                curPub = receiver.pub;
            });
            cascadeSession.active = false; window.closeOverlay(); await saveFullState();
        };

        window.execChPay = async function(id) {
            const c = simulationState.speedyChannels.find(x=>x.id===id), sIdx = +document.getElementById('ch-sender').value, amt = r2(Number(simulationState.activeAmount));
            if (isNaN(amt) || amt <= 0 || c.participants[sIdx].balance < amt) return;
            const sender = c.participants[sIdx], receiver = c.participants[sIdx === 0 ? 1 : 0];
            const msgId = Math.random().toString(36).substr(2, 9);
            multiPublish(`${CONFIG.TOPIC_P2P}/${receiver.node}`, JSON.stringify({ type: 'SPEEDY_CHANNEL_UPDATE', msgId: msgId, channelId: id, senderPub: sender.pub, amount: amt }));
            await saveFullState();
        };

        window.openOverlay = (t_str) => { 
            document.getElementById('overlay-title').innerText = t_str; 
            const overlay = document.getElementById('details-overlay');
            overlay.style.display = 'flex';
            setTimeout(() => overlay.classList.add('open'), 10);
        };
        window.closeOverlay = () => { 
            currentOpenedChannelId = null; activeOverlayId = null; 
            const overlay = document.getElementById('details-overlay');
            overlay.classList.remove('open');
            setTimeout(() => { overlay.style.display = 'none'; }, 300);
            window.renderAll(); 
        };
        
        let simulation, svg, g;
        function initNetworkViz() {
            svg = d3.select("#network-svg"); if(!svg.node()) return;
            const container = svg.node().parentElement;
            const w = container.clientWidth || 800, h = container.clientHeight || 600;
            g = svg.append("g"); svg.call(d3.zoom().scaleExtent([0.1, 5]).on("zoom", (e) => g.attr("transform", e.transform)));
            simulation = d3.forceSimulation().force("link", d3.forceLink().id(d => d.id).distance(150)).force("charge", d3.forceManyBody().strength(-400)).force("center", d3.forceCenter(w / 2, h / 2));
            updateNetworkViz();
        }

        function updateNetworkViz() {
            if(!g) return;
            const container = document.getElementById('network-svg').parentElement;
            const w = container.clientWidth, h = container.clientHeight;
            if (simulation && w > 0) simulation.force("center", d3.forceCenter(w / 2, h / 2));
            const nodes = simulationState.nodes.map(n => ({ id: n.id, local: n.instance === appInstanceId, blacklisted: n.blacklist && n.blacklist.size > 0 }));
            const links = []; 
            simulationState.nodes.forEach(n => { n.neighbors.forEach(nbid => { if (simulationState.nodes.some(x => x.id === nbid)) { const linkId = [n.id, nbid].sort().join('-'); if (!links.some(l => l.linkId === linkId)) links.push({ source: n.id, target: nbid, linkId }); } }); });
            g.selectAll("*").remove();
            const link = g.append("g").selectAll("line").data(links).enter().append("line").attr("class", "link");
            const node = g.append("g").selectAll("circle").data(nodes).enter().append("circle").attr("r", 12)
                .attr("fill", d => d.blacklisted ? "#ef4444" : (d.local ? "#4f46e5" : "#fb923c"))
                .attr("class", d => `node shadow-lg ${d.blacklisted ? 'node-blacklisted' : ''}`)
                .on("click", (e, d) => window.openNodeOverlay(d.id));
            simulation.nodes(nodes); simulation.force("link").links(links); simulation.alpha(1).restart();
            simulation.on("tick", () => { link.attr("x1", d => d.source.x).attr("y1", d => d.source.y).attr("x2", d => d.target.x).attr("y2", d => d.target.y); node.attr("cx", d => d.x).attr("cy", d => d.y); });
        }

        window.updateStepUI = function() {
            const container = document.getElementById('action-buttons'); if (!container) return;
            container.innerHTML = '';
            
            const steps = [
                { id: 'btn-init-net', index: 0, text: t('btn_init_net'), action: 'initNetwork', icon: 'network', topic: 'init_net' },
                { id: 'btn-init-accounts', index: 1, text: t('btn_init_accounts'), action: 'initAccounts', icon: 'users', topic: 'init_accounts' },
                { id: 'btn-init-assets', index: 2, text: t('btn_init_assets'), action: 'initBanknotes', icon: 'banknote', topic: 'init_assets' },
                { id: 'btn-init-channels', index: 3, text: t('btn_init_channels'), action: 'initChannels', icon: 'zap', topic: 'init_channels' }
            ];

            steps.forEach(s => {
                if (simulationState.step > s.index) return;
                
                const wrapper = document.createElement('div');
                wrapper.className = "flex items-center gap-1 group";
                
                const btn = document.createElement('button');
                btn.id = s.id; 
                btn.className = `btn-box ${simulationState.step === s.index ? 'btn-active' : 'btn-inactive'}`;
                btn.disabled = simulationState.step !== s.index;
                
                const iconSpan = document.createElement('span');
                iconSpan.innerHTML = `<i data-lucide="${s.icon}" size="18"></i>`;
                btn.appendChild(iconSpan);
                btn.appendChild(document.createTextNode(` ${s.text}`));
                
                btn.addEventListener('click', (e) => {
                    if (typeof window[s.action] === 'function') {
                        window[s.action]();
                    }
                });

                wrapper.appendChild(btn);
                
                const helpBtn = document.createElement('button');
                helpBtn.className = "help-q-mark ml-1";
                helpBtn.innerHTML = `<i data-lucide="help-circle" size="14"></i>`;
                helpBtn.onclick = (e) => { e.stopPropagation(); window.askAI(s.topic); };
                wrapper.appendChild(helpBtn);
                
                container.appendChild(wrapper);
            });
            
            const instr = document.getElementById('instruction-text');
            if(simulationState.step === 0) instr.innerText = t('instruction_0');
            else if(simulationState.step === 4) instr.innerText = t('instruction_4');
            else instr.innerText = `${t('ready_prefix')}${simulationState.readyFlags.join(', ')}${t('ready_suffix')}`;
            
            if(window.lucide) lucide.createIcons();
        };

        // Network Broker Initialization
        function initMqtt() {
            const isHttps = window.location.protocol === 'https:';
            const brokers = ['wss://test.mosquitto.org:8081', 'ws://test.mosquitto.org:8080'];
            const filteredBrokers = isHttps ? brokers.filter(url => url.startsWith('wss:')) : brokers;

            filteredBrokers.forEach((url, idx) => {
                try {
                    const client = mqtt.connect(url, { clientId: `aob_v25_${appInstanceId}_${idx}`, clean: true, connectTimeout: 10000 });
                    client.on('connect', () => { 
                        client.subscribe(CONFIG.TOPIC_MESH); client.subscribe(CONFIG.TOPIC_DISCOVERY); client.subscribe(`${CONFIG.TOPIC_P2P}/#`);
                        updateLanguageContent(); 
                        logger.log(`MQTT connected to ${url}`);
                    });
                    client.on('message', (topic, payload) => {
                        try {
                            const d = JSON.parse(payload.toString());
                            if (topic === CONFIG.TOPIC_MESH) { 
                                if (d.block) updateGlobalState(d.block); 
                                else if (d.relay) handleIncomingRelay(d.relay);
                            }
                            else if (topic === CONFIG.TOPIC_DISCOVERY) {
                                if (d.instance === appInstanceId) return;
                                let rNode = simulationState.nodes.find(x => x.id === d.id);
                                if (!rNode) { rNode = { id: d.id, instance: d.instance, neighbors: d.neighbors || [], logs: [], seenIds: new Set(), ledger: {}, blacklist: new Set() }; simulationState.nodes.push(rNode); }
                                if (d.type === 'HELLO') {
                                    const locals = simulationState.nodes.filter(n => n.instance === appInstanceId && n.neighbors.length < 8);
                                    if(locals[0]) {
                                        const ln = locals[Math.floor(Math.random() * locals.length)];
                                        if(!ln.neighbors.includes(d.id)) { ln.neighbors.push(d.id); rNode.neighbors.push(ln.id); multiPublish(CONFIG.TOPIC_DISCOVERY, JSON.stringify({ type: 'HELLO_BACK', id: ln.id, targetId: d.id, instance: appInstanceId, neighbors: ln.neighbors })); }
                                    }
                                }
                                if(simulation) updateNetworkViz();
                            } else if (topic.startsWith(CONFIG.TOPIC_P2P) && d.type === 'SPEEDY_CHANNEL_UPDATE') {
                                if (simulationState.processedIds.has(d.msgId)) return;
                                simulationState.processedIds.add(d.msgId);
                                const c = simulationState.speedyChannels.find(x => x.id === d.channelId);
                                if (c) {
                                    const sIdx = c.participants.findIndex(p => p.pub === d.senderPub);
                                    if (sIdx !== -1) {
                                        const rIdx = sIdx === 0 ? 1 : 0;
                                        c.participants[sIdx].balance = r2(c.participants[sIdx].balance - d.amount);
                                        c.participants[rIdx].balance = r2(c.participants[rIdx].balance + d.amount);
                                        c.history.push({ from: c.participants[sIdx].fp, to: c.participants[rIdx].fp, amount: d.amount, time: Date.now() });
                                        if (currentOpenedChannelId === d.channelId) window.refreshChannelUI(d.channelId);
                                        window.renderAll();
                                    }
                                }
                            }
                        } catch(e) {}
                    });
                    mqttClients.push(client);
                } catch(e) { logger.error("MQTT client connection failed."); }
            });
        }

        window.onload = function() { 
            logger.log("App starting up...");
            try {
                updateLanguageContent(); 
                window.updateStepUI(); 
                window.renderAll(); 
                initMqtt();
                logger.log("Startup sequence complete. Idle, waiting for manual interaction.");
            } catch (err) {
                logger.error("Startup crash:", err);
            }
        };

        /**
         * ---------------------------------------------------------------------------------------------------------------------
         * ATOMIC OWNERSHIP BLOCKCHAINS (AOB) PROTOCOL - CORE ARCHITECTURE & TECHNICAL PRINCIPLES
         * ---------------------------------------------------------------------------------------------------------------------
         * 1. PROTOCOL DESIGN GOALS:
         *    The AOB protocol aims for extreme decentralization where assets are self-contained blockchains. Horizontal 
         *    scalability is achieved because each asset chain state transition is independent.
         * 
         * 2. ASSET PROVENANCE:
         *    Cryptographic ownership is verified by traversing the chain from the current block back to the Genesis block.
         *    A transfer is valid only if signed by the public key defined as the "Target" of the immediate predecessor.
         * 
         * 3. FORK AWARENESS & DOUBLE-SPEND DEFENSE:
         *    Since assets are individual chains, double-spending manifests as a fork. Any node receiving two blocks pointing
         *    to the same Parent ID triggers a fork violation. The signing entity is blacklisted across the detecting node's 
         *    view, isolating the malicious actor from the local mesh.
         * 
         * 4. SPEEDY CHANNELS (L2):
         *    Off-chain efficiency is achieved by locking (mortgaging) main-chain banknotes into a multi-party signed channel
         *    contract. Transfers inside the channel occur via instant P2P updates, significantly lowering latency.
         * 
         * 5. ATOMIC CASCADE SETTLEMENT:
         *    Path-based routing allows payments between users with no direct channel. The cascade update is atomic; all
         *    intermediate participants update their balances simultaneously upon cryptographic proof exchange.
         * 
         * 6. CENTERLESS MESH TOPOLOGY:
         *    Discovery is handled through probabilistic gossip. Nodes maintain a small, dynamic set of peers to balance
         *    bandwidth usage and network reachability, ensuring no single point of failure (MQTT acts as the relay layer).
         * ---------------------------------------------------------------------------------------------------------------------
         */
    </script>
</body>
</html>